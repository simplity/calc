package org.simplity.calc.engine.impl;

import java.math.BigDecimal;

import org.antlr.v4.runtime.tree.ParseTree;
import org.simplity.calc.engine.api.ICalcFunction;
import org.simplity.calc.engine.api.IValue;
import org.simplity.calc.engine.api.ValueType;
import org.simplity.calc.engine.impl.BuiltinFunctions;
import org.simplity.calc.engine.impl.FunctionExpression;
import org.simplity.calc.engine.impl.IExpression;
import org.simplity.calc.engine.impl.LiteralExpression;
import org.simplity.calc.engine.impl.ValueFactory;
import org.simplity.calc.engine.impl.Variable;
import org.simplity.calc.engine.impl.VariableExpression;
import org.simplity.calc.grammar.CalcBaseVisitor;
import org.simplity.calc.grammar.CalcParser;
import org.simplity.calc.grammar.CalcParser.ExprContext;

/**
 * Builds a type-safe, executable {@link IExpression} tree from an ANTLR
 * ParseTree.
 *
 * <h3>Architectural Note</h3> A parser should ideally try to find as many
 * errors as possible and report them in a way that identifying the error and
 * means to fix them should be easy for the user. However, with the complex
 * relationship between various parts of an expression, such an attempt would be
 * quite complex as well as fragile and vulnerable. Hence this class throws
 * {@link IllegalArgumentException} at the first instance of an error
 * <p>
 */
final class AstBuilder extends CalcBaseVisitor<IExpression> {
	/**
	 * reference to be used while reporting any error
	 */
	private String expressionReference;
	private final IParserContext parserCtx;

	/**
	 * Constructs the AstBuilder.
	 *
	 */
	AstBuilder(IParserContext bootCtx) {
		this.parserCtx = bootCtx;
	}

	/**
	 * The main public entry point for building an expression tree.
	 *
	 * @param tree         The root of the parse tree generated by ANTLR.
	 * @param variableName for which this expression is being parsed
	 * @return The fully constructed and validated {@link IExpression}.
	 */
	public IExpression build(ParseTree tree, String variableName) {
		String expr = tree.getText();
		expr = expr.substring(0, expr.length() - 5); // remove <EOF> at the end
		this.expressionReference = "Rule for: " + variableName + "  Expression: " + expr;
		return this.visit(tree);
	}

	@Override
	public IExpression visitParse(CalcParser.ParseContext ctx) {
		// We override visitParse to specifically visit only the 'expr' child,
		// ignoring the EOF token. We then return the result of that visit.
		return this.visit(ctx.expr());
	}

	@Override
	public IExpression visitInfixExpr(CalcParser.InfixExprContext ctx) {
		/*
		 * 1. Visit children first to infer their types from the bottom up.
		 */
		IExpression left = this.visit(ctx.expr(0));
		IExpression right = this.visit(ctx.expr(1));

		/*
		 * 2. Get the inferred types.
		 */
		ValueType leftType = left.getValueType();
		ValueType rightType = right.getValueType();

		/*
		 * 3. Look up the overloaded function for this operator
		 */
		String op = ctx.op.getText();
		String functionName = BuiltinFunctions.buildFunctionKey(op, leftType, rightType);
		ICalcFunction function = this.parserCtx.getFunction(functionName);

		if (function != null) {
			return new FunctionExpression(function, new IExpression[] { left, right });
		}

		/*
		 * got an error. report it and return a dummy expression of left-type
		 */
		String msg = "Operator " + op + " is not valid between type '" + leftType.name().toLowerCase() + "' and '"
				+ rightType.name().toLowerCase();
		return this.ExpressionInError(msg, leftType);
	}

	@Override
	public IExpression visitUnaryExpr(CalcParser.UnaryExprContext ctx) {
		IExpression operand = this.visit(ctx.expr());
		ValueType operandType = operand.getValueType();

		String op = ctx.op.getText();
		if (op.equals("-")) {
			if (operandType != ValueType.NUMBER) {
				String msg = "Unary - is not applicable for value type '" + operandType.name().toLowerCase() + "'.";
				return this.ExpressionInError(msg, operandType);
			}
			op = "unary-";
		} else if (op.equals("!") && operandType != ValueType.BOOLEAN) {
			String msg = "Unary ! is not applicable for value type '" + operandType.name().toLowerCase() + "'.";
			return this.ExpressionInError(msg, operandType);
		}

		ICalcFunction function = this.parserCtx.getFunction(op);
		return new FunctionExpression(function, new IExpression[] { operand });
	}

	@Override
	public IExpression visitFuncExpr(CalcParser.FuncExprContext ctx) {

		String functionName = ctx.ID().getText();

		ICalcFunction function = this.parserCtx.getFunction(functionName);

		/*
		 * defined?
		 */
		if (function == null) {
			return this.ExpressionInError("function:" + functionName + " is not a valid function name",
					ValueType.NUMBER);
		}

		/*
		 * 2: parse the arguments
		 */
		final int n = ctx.expr().size();
		IExpression[] arguments = new IExpression[n];
		ValueType[] argTypes = new ValueType[n];

		for (int i = 0; i < n; i++) {
			ExprContext c = ctx.expr(i);
			IExpression exp = this.visit(c);
			arguments[i] = exp;
			argTypes[i] = exp.getValueType();
		}

		try {
			return new FunctionExpression(function, arguments);
		} catch (IllegalArgumentException e) {
			return this.ExpressionInError("Function: " + functionName + " has invalid arguments. " + e.getMessage(),
					function.getReturnType());

		}
	}

	/**
	 * log the error for this message and return a dummy expression of the same
	 * type, so that the parsing process can continue to look for other problems
	 */
	private IExpression ExpressionInError(String message, ValueType valueType) {
		this.parserCtx.logError(message, "expresion", this.expressionReference);
		return new LiteralExpression(ValueFactory.newDefaultValue(valueType));
	}

	@Override
	public IExpression visitVariableExpr(CalcParser.VariableExprContext ctx) {
		String variableName = ctx.ID().getText();
		Variable variable = this.parserCtx.getVariable(variableName);
		if (variable == null) {
			return this.ExpressionInError("Variable '" + variableName + "' is not defined.", ValueType.NUMBER);
		}
		return new VariableExpression(variableName, variable.getValueType());
	}

	@Override
	public IExpression visitLiteralExpr(CalcParser.LiteralExprContext ctx) {
		// Literals are base cases; their type is self-evident.
		return this.visit(ctx.literal());
	}

	@Override
	public IExpression visitLiteral(CalcParser.LiteralContext ctx) {
		IValue value = null;
		if (ctx.NUMBER() != null) {
			value = ValueFactory.newValue(new BigDecimal(ctx.NUMBER().getText()));
		} else if (ctx.STRING() != null) {
			String text = ctx.STRING().getText();
			text = text.substring(1, text.length() - 1).replace("''", "'");
			value = ValueFactory.newValue(text);
		} else if (ctx.BOOLEAN() != null) {
			value = ValueFactory.newValue(Boolean.parseBoolean(ctx.BOOLEAN().getText()));
		} else {
			return this.ExpressionInError("Literal type: " + ctx.getText() + " is not yet implemented",
					ValueType.NUMBER);
		}
		return new LiteralExpression(value);
	}

	@Override
	public IExpression visitParenExpr(CalcParser.ParenExprContext ctx) {
		// Pass through to the inner expression. Type is inferred upwards.
		return this.visit(ctx.expr());
	}

}