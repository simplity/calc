package org.simplity.calc.engine.impl;

import java.math.BigDecimal;

import org.antlr.v4.runtime.tree.ParseTree;
import org.simplity.calc.engine.api.DataType;
import org.simplity.calc.engine.api.ICalcFunction;
import org.simplity.calc.engine.api.IValue;
import org.simplity.calc.engine.api.IValueType;
import org.simplity.calc.grammar.CalcBaseVisitor;
import org.simplity.calc.grammar.CalcParser;
import org.simplity.calc.grammar.CalcParser.ExprContext;

/**
 * Builds a type-safe, executable {@link IExpression} tree from an ANTLR
 * ParseTree.
 *
 * <h3>Architectural Note</h3> A parser should ideally try to find as many
 * errors as possible and report them in a way that identifying the error and
 * means to fix them should be easy for the user. However, with the complex
 * relationship between various parts of an expression, such an attempt would be
 * quite complex as well as fragile and vulnerable. Hence this class throws
 * {@link IllegalArgumentException} at the first instance of an error
 * <p>
 * <h3>Design Note</h3> ANTLR is used to parse an expression and create a parsed
 * tree of tokens. Visitor pattern is used to process these tokens.Once the
 * expression is syntactically validated, it is then validated for semantics,
 * like the right operand-types for the operators etc.. During this process, any
 * error is reported, but the process continues with a view to detect as many
 * errors as possible
 *
 * <p>
 * vistXXX methods are to be read after understanding the antlr file (Calc.g4).
 * These methods extend the based methods that are generated by the antlr
 * code-generator based on the grammar specified in Calc.g4
 *
 * @refer org.simplity.calc.grammar.Calc.g4 under src/main/antlr folder
 */
final class AstBuilder extends CalcBaseVisitor<IExpression> {
	/**
	 * reference to be used while reporting any error
	 */
	private String expressionReference;
	private final IEngineBuilder engineBuilder;

	/**
	 * Constructs the AstBuilder.
	 *
	 */
	AstBuilder(IEngineBuilder builder) {
		this.engineBuilder = builder;
	}

	/**
	 * The main public entry point for building an expression tree.
	 *
	 * @param tree         The root of the parse tree generated by ANTLR.
	 * @param variableName for which this expression is being parsed
	 * @return The fully constructed and validated {@link IExpression}.
	 */
	public IExpression build(ParseTree tree, String variableName) {
		String expr = tree.getText();
		expr = expr.substring(0, expr.length() - 5); // remove <EOF> at the end
		this.expressionReference = "Rule for: " + variableName + "  Expression: " + expr;

		/**
		 * trigger the visitor pattern at the top. Note that the base class
		 * {@link CalcBaseVisitor} will call-back the visitxxx methods that are extended
		 * in this class
		 */
		return super.visit(tree);
	}

	@Override
	public IExpression visitParse(CalcParser.ParseContext ctx) {
		/**
		 * this is the top level token. As per ANTLR standard, we would have EOF as the
		 * next token. We should ignore that and visit only the main expression
		 */
		return this.visit(ctx.expr());
	}

	@Override
	public IExpression visitInfixExpr(CalcParser.InfixExprContext ctx) {
		/*
		 * 1. Visit children first to infer their types from the bottom up.
		 */
		IExpression left = this.visit(ctx.expr(0));
		IExpression right = this.visit(ctx.expr(1));

		/*
		 * 2. Get the inferred types.
		 */
		IValueType leftType = left.getValueType();
		IValueType rightType = right.getValueType();

		/**
		 * 3. check for right type of operands all binary operators operate on matching
		 * left and right operators
		 */
		String op = ctx.op.getText();
		if (leftType.equals(rightType) == false || validateBinaryOp(op, leftType) == false) {
			String msg = "Operator " + op + " is not valid between type '" + leftType + "' and '" + rightType;
			return this.ExpressionInError(msg, leftType.getDataType());
		}

		/*
		 * 4. Look up the function for this operator
		 */
		ICalcFunction function = this.engineBuilder.getFunction(op);

		if (function == null) {
			String msg = "Internal Error: Operator " + op
					+ " is recognized as a valid operator, but it not fully implemented'";
			return this.ExpressionInError(msg, leftType.getDataType());
		}
		return new FunctionExpression(function, new IExpression[] { left, right });

	}

	@Override
	public IExpression visitUnaryExpr(CalcParser.UnaryExprContext ctx) {
		IExpression operand = this.visit(ctx.expr());
		DataType operandType = operand.getValueType().getDataType();

		/*
		 * we have only 2 unary operators '-' and '!' we may have to refactor the code
		 * if and when we add more unary operators
		 */
		String op = ctx.op.getText();
		if (op.equals("-")) {
			if (operandType != DataType.NUMBER) {
				String msg = "Unary - is not applicable for value type '" + operandType.name().toLowerCase() + "'.";
				return this.ExpressionInError(msg, operandType);
			}
			/**
			 * function for unary- is named as "unary-"
			 */
			op = "unary-";
		} else if (op.equals("!") && operandType != DataType.BOOLEAN) {
			String msg = "Unary ! is not applicable for value type '" + operandType.name().toLowerCase() + "'.";
			return this.ExpressionInError(msg, operandType);
		}

		ICalcFunction function = this.engineBuilder.getFunction(op);
		return new FunctionExpression(function, new IExpression[] { operand });
	}

	@Override
	public IExpression visitFuncExpr(CalcParser.FuncExprContext ctx) {

		String functionName = ctx.ID().getText();

		ICalcFunction function = this.engineBuilder.getFunction(functionName);

		/*
		 * defined?
		 */
		if (function == null) {
			return this.ExpressionInError("function:" + functionName + " is not a valid function name",
					DataType.NUMBER);
		}

		/*
		 * 2: parse the arguments
		 */
		final int n = ctx.expr().size();
		IExpression[] arguments = new IExpression[n];
		DataType[] argTypes = new DataType[n];

		for (int i = 0; i < n; i++) {
			ExprContext c = ctx.expr(i);
			IExpression exp = this.visit(c);
			arguments[i] = exp;
			argTypes[i] = exp.getValueType().getDataType();
		}

		/*
		 * FunctionExpression validates the number and types of the argument
		 */
		try {
			return new FunctionExpression(function, arguments);
		} catch (IllegalArgumentException e) {
			return this.ExpressionInError("Function: " + functionName + " has invalid arguments. " + e.getMessage(),
					function.getReturnType().getDataType());
		}
	}

	@Override
	public IExpression visitVariableExpr(CalcParser.VariableExprContext ctx) {
		String variableName = ctx.ID().getText();
		IVariable variable = this.engineBuilder.getVariable(variableName);
		if (variable == null) {
			return this.ExpressionInError("Variable '" + variableName + "' is not defined.", DataType.NUMBER);
		}
		return new VariableExpression(variableName, variable.getValueType());
	}

	@Override
	public IExpression visitLiteralExpr(CalcParser.LiteralExprContext ctx) {
		// Literals are base cases; their type is self-evident.
		return this.visit(ctx.literal());
	}

	@Override
	public IExpression visitLiteral(CalcParser.LiteralContext ctx) {
		IValue value = null;
		if (ctx.NUMBER() != null) {
			value = Values.newValue(new BigDecimal(ctx.NUMBER().getText()));
		} else if (ctx.STRING() != null) {
			String text = ctx.STRING().getText();
			text = text.substring(1, text.length() - 1).replace("''", "'");
			value = Values.newValue(text);
		} else if (ctx.BOOLEAN() != null) {
			value = Values.newValue(Boolean.parseBoolean(ctx.BOOLEAN().getText()));
		} else if (ctx.enumType != null) {
			value = Values.newEnumeratedValue(ctx.enumType.getText(), ctx.enumName.getText());
		} else {
			return this.ExpressionInError("Literal type: " + ctx.getText() + " is not yet implemented",
					DataType.NUMBER);
		}
		return new LiteralExpression(value);
	}

	@Override
	public IExpression visitParenExpr(CalcParser.ParenExprContext ctx) {
		// Pass through to the inner expression. Type is inferred upwards.
		return this.visit(ctx.expr());
	}

	/**
	 * log the error for this message and return a dummy expression of the same
	 * type, so that the parsing process can continue to look for other problems
	 */
	private IExpression ExpressionInError(String message, DataType dataType) {
		this.engineBuilder.logError(message, "expresion", this.expressionReference);
		return new LiteralExpression(Values.newDefaultValue(dataType));
	}

	private static boolean validateBinaryOp(String op, IValueType valueType) {
		DataType type = valueType.getDataType();
		switch (op) {
		// arithmetic operators are for numbers
		case "+":
		case "-":
		case "*":
		case "/":
		case "%":
			return type == DataType.NUMBER;

		// logical operators are for booleans
		case "|":
		case "&":
			return type == DataType.BOOLEAN;

		// matching is for all
		case "=":
		case "!=":
			return true;

		//
		case "<":
		case ">":
		case "<=":
		case ">=":
			return type == DataType.NUMBER || type == DataType.STRING || type == DataType.DATE
					|| type == DataType.TIMESTAMP;

		default:
			return false;
		}
	}

}