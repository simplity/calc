package org.simplity.calc.impl;

import java.math.BigDecimal;

import org.antlr.v4.runtime.tree.ParseTree;
import org.simplity.calc.api.ICalcFunction;
import org.simplity.calc.api.IValue;
import org.simplity.calc.api.ValueType;
import org.simplity.calc.grammar.CalcBaseVisitor;
import org.simplity.calc.grammar.CalcParser;
import org.simplity.calc.grammar.CalcParser.ExprContext;

/**
 * Builds a type-safe, executable {@link IExpression} tree from an ANTLR
 * ParseTree.
 *
 * <h3>Architectural Note</h3> A parser should ideally try to find as many
 * errors as possible and report them in a way that identifying the error and
 * means to fix them should be easy for the user. However, with the complex
 * relationship between various parts of an expression, such an attempt would be
 * quite complex as well as fragile and vulnerable. Hence this class throws
 * {@link IllegalArgumentException} at the first instance of an error
 * <p>
 */
final class AstBuilder extends CalcBaseVisitor<IExpression> {

	private final IParserContext parserCtx;

	/**
	 * Constructs the AstBuilder.
	 *
	 */
	AstBuilder(IParserContext bootCtx) {
		this.parserCtx = bootCtx;
	}

	/**
	 * The main public entry point for building an expression tree.
	 *
	 * @param tree         The root of the parse tree generated by ANTLR.
	 * @param variableName for which this expression is being parsed
	 * @return The fully constructed and validated {@link IExpression}.
	 */
	public IExpression build(ParseTree tree, String variableName) {
		return this.visit(tree);
	}

	@Override
	public IExpression visitInfixExpr(CalcParser.InfixExprContext ctx) {
		/*
		 * 1. Visit children first to infer their types from the bottom up.
		 */
		IExpression left = this.visit(ctx.expr(0));
		IExpression right = this.visit(ctx.expr(1));

		/*
		 * 2. Get the inferred types.
		 */
		ValueType leftType = left.getValueType();
		ValueType rightType = right.getValueType();

		/*
		 * 3. Look up the correctly overloaded function for this operator
		 */
		String op = ctx.op.getText();
		String functionName = BuiltinFunctions.formatFunctionName(op, leftType, rightType);
		ICalcFunction function = this.parserCtx.getFunction(functionName);
		if (function == null) {
			throw new IllegalArgumentException("Operator '" + op + "' is not valid between type '"
					+ leftType.name().toLowerCase() + "' and '" + rightType.name().toLowerCase());
		}

		/*
		 * 4. Create the expression node.
		 */
		return new FunctionExpression(function, new IExpression[] { left, right });
	}

	@Override
	public IExpression visitUnaryExpr(CalcParser.UnaryExprContext ctx) {
		IExpression operand = this.visit(ctx.expr());
		ValueType operandType = operand.getValueType();
		String op = ctx.op.getText();
		if (op.equals("-")) {
			if (operandType != ValueType.NUMBER) {
				throw new IllegalArgumentException(
						"Unary - is not pplicable for value type '" + operandType.name().toLowerCase() + "'.");
			}
			op = "unary-";
		}

		ICalcFunction function = this.parserCtx.getFunction(op);
		return new FunctionExpression(function, new IExpression[] { operand });
	}

	@Override
	public IExpression visitFuncExpr(CalcParser.FuncExprContext ctx) {
		String functionName = ctx.ID().getText();
		ICalcFunction function = this.parserCtx.getFunction(functionName);

		/*
		 * 1: Is this function defined?
		 */
		if (function == null) {
			throw new IllegalArgumentException(functionName + " is not a valid function name");
		}

		/*
		 * 2: parse the arguments
		 */
		int n = ctx.expr().size();
		IExpression[] arguments = new IExpression[n];
		ValueType[] argTypes = new ValueType[n];
		n = 0;
		for (ExprContext c : ctx.expr()) {
			IExpression exp = this.visit(c);
			arguments[n] = exp;
			argTypes[n] = exp.getValueType();
			n++;
		}

		/*
		 * 3: do we have the right number of arguments
		 */
		boolean isVarArg = function.lastOneIsVararg();
		ValueType[] expectedTypes = function.getParameterTypes();
		int min = expectedTypes.length;
		if (isVarArg) {
			min--;
			if (n < min) {
				throw new IllegalArgumentException("Function '" + functionName + "' requires at least " + min
						+ " arguments but  " + n + " arguments provided.");
			}

		} else if (n != min) {
			throw new IllegalArgumentException("Function '" + functionName + "' requires " + min + " arguments but  "
					+ n + " arguments provided.");
		}

		/*
		 * 4: what about argument types?
		 */
		for (int i = 0; i < min; i++) {
			ValueType vt = expectedTypes[i];
			/*
			 * null implies any type
			 */
			if (vt != null && !vt.equals(argTypes[i])) {
				throw new IllegalArgumentException(
						"Function '" + functionName + "': argument at position " + (i + 1) + " should be a "
								+ vt.name().toLowerCase() + " but it is a " + argTypes[i].name().toLowerCase());
			}
		}

		/*
		 * 5: arg type for varargs
		 */
		if (n > min) {
			ValueType vt = expectedTypes[min];
			if (vt != null) {
				for (int i = min; i < n; i++) {
					if (vt.equals(argTypes[i])) {
						continue;
					}
					throw new IllegalArgumentException(
							"Function '" + functionName + "': argument at position " + (i + 1) + " should be a "
									+ vt.name().toLowerCase() + " but it is a " + argTypes[i].name().toLowerCase());
				}
			}
		}

		/*
		 * All Right!!
		 */
		return new FunctionExpression(function, arguments);

	}

	@Override
	public IExpression visitVariableExpr(CalcParser.VariableExprContext ctx) {
		String variableName = ctx.ID().getText();
		ValueType type = this.parserCtx.getValueType(variableName);
		if (type == null) {
			throw new IllegalArgumentException("Variable '" + variableName + "' is not defined.");
		}
		return new VariableExpression(variableName, type);
	}

	@Override
	public IExpression visitLiteralExpr(CalcParser.LiteralExprContext ctx) {
		// Literals are base cases; their type is self-evident.
		return this.visit(ctx.literal());
	}

	@Override
	public IExpression visitLiteral(CalcParser.LiteralContext ctx) {
		IValue value = null;
		if (ctx.NUMBER() != null) {
			value = ValueFactory.newValue(new BigDecimal(ctx.NUMBER().getText()));
		} else if (ctx.STRING() != null) {
			String text = ctx.STRING().getText();
			text = text.substring(1, text.length() - 1).replace("''", "'");
			value = ValueFactory.newValue(text);
		} else if (ctx.BOOLEAN() != null) {
			value = ValueFactory.newValue(Boolean.parseBoolean(ctx.BOOLEAN().getText()));
		} else {
			throw new IllegalArgumentException("Literal type: " + ctx.getText() + " is not yet implemented");
		}
		return new LiteralExpression(value);
	}

	@Override
	public IExpression visitParenExpr(CalcParser.ParenExprContext ctx) {
		// Pass through to the inner expression. Type is inferred upwards.
		return this.visit(ctx.expr());
	}

}